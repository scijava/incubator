package templates.matcher.impl

import main.plusAssign
import templates.Globals
import java.io.File

class OpWrappers(sourceDir: File) : Globals(sourceDir,
                                            "org/scijava/ops/engine/matcher/impl",
                                            "OpWrappers") {

    val arities = 1..maxArity

    fun inplaceTypeVarNums(arity: Int, io: Int): List<Any> {
        val a = (1..arity).toList()
        return a.subList(0, io - 1) + 'O' + a.subList(io, arity)
    }

    fun inplaceGenericsList(arity: Int, io: Int): List<String> {
        val a = inplaceTypeVarNums(arity, io)
        return inplaceTypeVarNums(arity, io).map { "I$it" }
    }

    fun inplaceTypeParams(arity: Int, io: Int) = "<${inplaceGenericsList(arity, io).joinToString()}>"

    fun nilArgs(arity: Int) = nilNames(arity).joinToString()

    fun genericFunctionGenerics(arity: Int) = if (arity == 0) "GenericTypedProducer<O>" else "GenericTypedFunction$arity${generics(arity)}"

    fun genericComputerGenerics(arity: Int) = "GenericTypedComputer$arity<${genericParamTypes(arity).joinToString()}>"

    fun genericInplaceGenerics(arity: Int, io: Int) = "GenericTypedInplace$arity<${inplaceGenericsList(arity, io).joinToString()}>"

    fun functionGenerics(arity: Int): String {
        val a = genericParamTypes(arity)
        val b = a.joinToString()
        return "${functionArity(arity)}<${genericParamTypes(arity).joinToString()}>"
    }

    fun computerGenerics(arity: Int) = "${computerArity(arity)}<${genericParamTypes(arity).joinToString()}>"

    fun inplaceGenerics(arity: Int, io: Int) = "${inplaceType(arity, io)}<${inplaceGenericsList(arity, io).joinToString()}>"

    fun matchParams(arity: Int): String {
        // contains "I1, I2, ..., IN, O"
        val gpt = genericParamTypes(arity)
        // contains "in1, in2, ..., inN, out"
        val names = nilNames(arity)
        // constructing strings of the term "final Nil<I1> in1"
        val nilArgs = (0..arity).map { "final Nil<${gpt[it]}> ${names[it]}" }
        return nilArgs.joinToString()
    }

    fun mutateArgsList(arity: Int, io: Int) = inplaceTypeVarNums(arity, io).map { if (it == 'O') "ioType" else "in${it}Type" }

    fun mutateParams(arity: Int, io: Int): String {
        val args = mutateArgsList(arity, io)
        val types = inplaceGenericsList(arity, io)
        return (0 until arity).joinToString { "${types[it]} ${args[it]}" }
    }

    fun mutateArgs(arity: Int, io: Int) = mutateArgsList(arity, io).joinToString()


    override fun generate(text: StringBuilder) {
        text += """/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.ops.engine.matcher.impl;

import java.util.function.BiFunction;
import java.util.function.Function;

import org.scijava.function.Computers;
import org.scijava.function.Container;
import org.scijava.function.Functions;
import org.scijava.function.Inplaces;
import org.scijava.function.Producer;
import org.scijava.ops.api.OpInstance;
import org.scijava.ops.api.OpMetadata;
import org.scijava.ops.api.OpWrapper;
import org.scijava.ops.api.RichOp;
import org.scijava.plugin.Plugin;

public class OpWrappers {

	// -- producer --

	@Plugin(type = OpWrapper.class)
	public static class ProducerOpWrapper<T> implements OpWrapper<Producer<T>> {

		@Override
		public RichOp<Producer<T>> wrap(final OpInstance<Producer<T>> instance, //
			final OpMetadata metadata)
		{
			class GenericTypedProducer //
				extends AbstractRichOp<Producer<T>> //
				implements Producer<T>
			{

				public GenericTypedProducer()
				{
					super(instance, metadata);
				}

				@Override
				public T create() {
					preprocess();

					// Call the op
					T out = instance.op().create();

					postprocess(out);

					return out;
				}

				@Override
				public Producer<T> asOpType() {
					return this;
				}

			}
			return new GenericTypedProducer();
		}
	}

	// -- functions --
"""
        for (arity in 1..maxArity) {
            val fg = functionGenerics(arity)
            text += """	@Plugin(type = OpWrapper.class)
	public static class Function${arity}OpWrapper${generics(arity)} //
		implements //
		OpWrapper<$fg>
	{

		@Override
		public RichOp<$fg> wrap( //
			final OpInstance<$fg> instance, //
			final OpMetadata metadata)
		{
			class GenericTypedFunction$arity //
				extends AbstractRichOp<$fg> //
				implements $fg 
			{

				public GenericTypedFunction$arity()
				{
					super(instance, metadata);
				}

				@Override
				public O apply(${applyParams(arity)}) //
				{
					preprocess(${applyArgs(arity)});

					// Call the op
					O out = instance.op().apply(${applyArgs(arity)});

					postprocess(out);
					return out;
				}

				@Override
				public $fg asOpType() {
					return this;
				}

			}
			return new GenericTypedFunction$arity();
		}
	}
"""
        }

        text += "\t// -- computers --"

        for(arity in 0..maxArity) {
            val cg = computerGenerics(arity)
            text += """	@Plugin(type = OpWrapper.class)
	public static class Computer${arity}OpWrapper${generics(arity)} //
		implements //
		OpWrapper<$cg>
	{

		@Override
		public RichOp<$cg> wrap( //
			final OpInstance<$cg> instance, //
			final OpMetadata metadata)
		{
			class GenericTypedComputer$arity //
				extends AbstractRichOp<$cg> //
				implements $cg 
			{
				public GenericTypedComputer$arity()
				{
					super(instance, metadata);
				}

				@Override
				public void compute(${computeParams(arity)}) //
				{
					preprocess(${computeArgs(arity)});

					// Call the op
					instance.op().compute(${computeArgs(arity)});

					postprocess(out);
				}

				@Override
				public $cg asOpType() {
					return this;
				}

			}
			return new GenericTypedComputer$arity();
		}
	}
"""
        }

        text += "\t// -- inplaces --"

        for(arity in 1..maxArity)
            for(a in 1..arity) {
                val ig = inplaceGenerics(arity, a)
                text += """	@Plugin(type = OpWrapper.class)
	public static class Inplace${inplaceSuffix(arity, a)}OpWrapper${inplaceTypeParams(arity, a)} //
		implements //
		OpWrapper<$ig> //
	{

		@Override
		public RichOp<$ig> wrap( //
			final OpInstance<$ig> instance, //
			final OpMetadata metadata)
		{
			class GenericTypedInplace${inplaceSuffix(arity, a)} //
				extends AbstractRichOp<$ig> //
				implements $ig 
			{
				public GenericTypedInplace${inplaceSuffix(arity, a)}()
				{
					super(instance, metadata);
				}

				@Override
				public void mutate(${mutateParams(arity, a)}) //
				{
					preprocess(${mutateArgs(arity, a)});

					// Call the op
					instance.op().mutate(${mutateArgs(arity, a)});

					// Log a new execution
					postprocess(ioType);
				}

				@Override
				public $ig asOpType() {
					return this;
				}

			}
			return new GenericTypedInplace${inplaceSuffix(arity, a)}();
		}
	}
"""
            }

        text += "}"
    }
}