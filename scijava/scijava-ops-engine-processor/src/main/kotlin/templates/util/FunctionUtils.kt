package templates.util

import main.plusAssign
import templates.Globals
import java.io.File

class FunctionUtils(sourceDir: File) : Globals(sourceDir,
                                               "org/scijava/ops/engine/util",
                                               "FunctionUtils") {

    val arities = 3..maxArity

    fun genericsO2(arity: Int) = if(arity == 0) "<O2>" else "<${(1..arity).joinToString { "I$it" }}, O2>"

    fun matchParams(arity: Int): String {
        val generics = genericParamTypes(arity)
        val names = genericsNamesList(arity)
        return (0..arity).joinToString{"final Nil<${generics[it]}> ${names[it]}Type"}
    }

    fun nilArgs(arity: Int): String {
        val names = genericsNamesList(arity).toMutableList()
        val out = names.removeLast()
        names.add(0, out)
        return names.joinToString{"${it}Type"}
    }

    fun objectGenerics(arity: Int) = "<${(1..arity).joinToString { "Object" }}, O>"

    fun insArgs(arity: Int) = (0 until arity).joinToString{ "ins[$it]" }


    override fun generate(text: StringBuilder) {
        text += """/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.ops.engine.util;

import java.lang.reflect.Type;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.Function;

import org.scijava.function.Functions;
import org.scijava.function.Producer;
import org.scijava.ops.api.OpEnvironment;
import org.scijava.ops.api.Hints;
import org.scijava.types.Nil;
import org.scijava.types.Types;

/**
 * Utility class designed to match {@code Function}s of various arities.
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public final class FunctionUtils {

	private FunctionUtils() {
		// NB: Prevent instantiation of utility class.
	}

	@SuppressWarnings({ "unchecked" })
	public static <O, T> Functions.ArityN<O> matchN(final OpEnvironment env,
		final String opName, final Nil<O> outType, final Nil<?>... inTypes)
	{
		Map.Entry<Integer, Class<?>> c = Functions.ALL_FUNCTIONS //
			.entrySet().stream() //
			.filter(e -> e.getKey() == inTypes.length) //
			.findAny().get();
		Object op = matchHelper(env, opName, c.getValue(), outType, inTypes);
		if (op instanceof Producer) {
			return Functions.nary((Producer<O>) op);
		}"""

        val maxMinusOne = maxArity - 1
        for(arity in 1..maxMinusOne)
            text += """		else if (op instanceof ${functionArity(arity)}) {
			return Functions.nary((${functionArity(arity)}${objectGenerics(arity)}) op);
		}"""

        text+="""		return Functions.nary((${functionArity(maxArity)}${objectGenerics(maxArity)}) op);
	}

	@SuppressWarnings({ "unchecked" })
	private static <T> T matchHelper(final OpEnvironment env, final String opName,
		final Class<T> opClass, final Nil<?> outType, final Nil<?>... inTypes)
	{
		final Type[] types = new Type[inTypes.length + 1];
		for (int i = 0; i < inTypes.length; i++)
			types[i] = inTypes[i].getType();
		types[types.length - 1] = outType.getType();
		final Type specialType = Types.parameterize(opClass, types);
		return (T) env.op(opName, Nil.of(specialType), inTypes, outType);
	}
}
"""
    }
}