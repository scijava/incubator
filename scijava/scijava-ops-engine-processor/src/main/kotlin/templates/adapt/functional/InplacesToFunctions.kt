package templates.adapt.functional

import main.plusAssign
import templates.Globals
import java.io.File

class InplacesToFunctions(sourceDir: File) : Globals(sourceDir,
                                                     "org/scijava/ops/engine/adapt/functional",
                                                     "InplacesToFunctions") {

    val arities = 1..maxArity

    fun simplifiedClass(arity: Int, num: Int) = "${simplifiedInplace(arity, num)}.class"

    fun inplaceClass(arity: Int, num: Int) = inplaceType(arity, num) + ".class"

    fun typeVarNums(arity: Int, io: Int): List<Any> {
        val a = (1..arity).toList()
        return a.subList(0, io - 1) + 'O' + a.subList(io, arity)
    }

    fun genericsList(arity: Int, io: Int) = typeVarNums(arity, io).map { "I$it" }

    fun generics(arity: Int, io: Int) = "<${genericsList(arity, io).joinToString()}>"

    fun functionGenerics(arity: Int, io: Int) = "<${genericsList(arity, io).joinToString()}, IO>"

    fun allMutableGenericsList(arity: Int) = (1..arity).map { "IO$it" }

    fun allMutableGenerics(arity: Int) = "<${allMutableGenericsList(arity).joinToString()}>"

    fun basicParamsList(arity: Int, io: Int) = typeVarNums(arity, io).map { if (it == 'O') "ioType" else "in${it}Type" }

    fun basicParams(arity: Int, io: Int) = basicParamsList(arity, io).joinToString()

    fun matchName(arity: Int, num: Int) = if (arity == 1) "match" else "match$num"

    fun matchParams(arity: Int, io: Int): String =
        genericsList(arity, io).joinToString {
            when {
                it[1] == 'O' -> "final Nil<$it> ${it.toLowerCase()}Type"
                else -> "final Nil<$it> in${it.drop(1)}Type"
            }
        }

    fun typeArgs(arity: Int, io: Int) = basicParamsList(arity, io).joinToString { "$it.getType()" }

    fun allMutableMutateParams(arity: Int) = allMutableGenericsList(arity).joinToString { "@Mutable $it ${it.toLowerCase()}" }

    fun allMutableMutateArgs(arity: Int) = allMutableGenericsList(arity).joinToString { it.toLowerCase() }

    fun mutateArgs(arity: Int, io: Int) = genericsList(arity, io).joinToString { if (it.drop(1) == "O") "IO io" else "$it in${it.drop(1)}" }

    fun mutateParams(arity: Int, io: Int) = genericsList(arity, io).joinToString { if (it.drop(1) == "O") "io" else "in${it.drop(1)}" }

    fun mutateTempParams(arity: Int, io: Int) = genericsList(arity, io).joinToString { if (it.drop(1) == "O") "temp" else "in${it.drop(1)}" }


    override fun generate(text: StringBuilder) {
        text += """/*
 * #%L
 * SciJava Operations: a framework for reusable algorithms.
 * %%
 * Copyright (C) 2016 - 2019 SciJava Ops developers.
 * %%
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * #L%
 */

/*
* This is autogenerated source code -- DO NOT EDIT. Instead, edit the
* corresponding template in templates/ and rerun bin/generate.groovy.
*/

package org.scijava.ops.engine.adapt.functional;

import java.util.function.BiFunction;
import java.util.function.Function;

import org.scijava.function.Computers;
import org.scijava.function.Functions;
import org.scijava.function.Inplaces;
import org.scijava.ops.spi.Op;
import org.scijava.ops.spi.OpClass;
import org.scijava.ops.spi.OpCollection;
import org.scijava.ops.spi.OpDependency;
import org.scijava.plugin.Plugin;
"""
        val classArity = maxArity + 1

        text += """/**
 * Collection of adaptation Ops to convert {@link Inplaces} into
 * {@link Functions}.
 * 
 * @author Gabriel Selzer
 */
@Plugin(type = OpCollection.class)
public class InplacesToFunctions${generics(classArity, classArity)} {
"""
        for (arity in 1..maxArity)
            for (a in 1..arity)
                text += """	@OpClass(names = "adapt")
	static class Inplace${inplaceSuffix(arity, a)}ToFunction$arity${generics(arity, a)} implements Function<${inplaceType(arity, a)}${generics(arity, a)}, ${functionArity(arity)}${functionGenerics(arity, a)}>, Op {
		
		@OpDependency(name = "create", adaptable = false)
		private Function<IO, IO> createOp;
		@OpDependency(name = "copy", adaptable = false)
		private Computers.Arity1<IO, IO> copyOp;

		/**
		 * @param t the Inplace to adapt
		 * @return an adaptation of inplace
		 */
		@Override
		public ${functionArity(arity)}${functionGenerics(arity, a)} apply(${inplaceType(arity, a)}${generics(arity, a)} t) {
			return (${mutateArgs(arity, a)}) -> {
				IO temp = createOp.apply(io);
				copyOp.accept(io, temp);
				t.mutate(${mutateTempParams(arity, a)});
				return temp;
			};
		}
	}
"""
        text += "}"
    }
}