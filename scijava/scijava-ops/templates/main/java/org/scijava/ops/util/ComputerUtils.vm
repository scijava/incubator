/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.ops.util;

import java.lang.reflect.Type;
import java.util.function.Consumer;

import org.scijava.function.Computers;
import org.scijava.ops.OpEnvironment;
import org.scijava.ops.Hints;
import org.scijava.types.Nil;
import org.scijava.types.Types;

/**
 * Container class for computer-style functional interfaces at various
 * <a href="https://en.wikipedia.org/wiki/Arity">arities</a>.
 * <p>
 * A computer has functional method {@code compute} with a number of arguments
 * corresponding to the arity, plus an additional argument for the preallocated
 * output to be populated by the computation.
 * </p>
 * <p>
 * Each computer interface implements a corresponding {@link Consumer}-style
 * interface (see {@link Consumers}) with arity+1; the consumer's {@code accept}
 * method simply delegates to {@code compute}. This pattern allows computer ops
 * to be used directly as consumers as needed.
 * </p>
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public final class ComputerUtils {

	private ComputerUtils() {
		// NB: Prevent instantiation of utility class.
	}

#foreach($arity in [0..$maxArity])
	@SuppressWarnings("unchecked")
	public static $generics.call($arity) $computerArity.call($arity)$generics.call($arity) match(final OpEnvironment env, final String opName, $matchParams.call($arity))
	{
		return matchHelper(env, opName, ${computerArity.call($arity)}.class, $nilArgs.call($arity));
	}

#end
#foreach($arity in [0..$maxArity])
	@SuppressWarnings("unchecked")
	public static $generics.call($arity) $computerArity.call($arity)$generics.call($arity) match(final OpEnvironment env, final String opName, $matchParams.call($arity), final Hints hints)
	{
		return matchHelper(env, opName, hints, ${computerArity.call($arity)}.class, $nilArgs.call($arity));
	}

#end
	@SuppressWarnings({ "unchecked" })
	private static <T> T matchHelper(final OpEnvironment env, final String opName, final Class<T> opClass, final Nil<?> outType, final Nil<?>... inTypes)
	{
		final Type[] types = new Type[inTypes.length + 1];
		for (int i = 0; i < inTypes.length; i++)
			types[i] = inTypes[i].getType();
		types[types.length - 1] = outType.getType();
		final Type specialType = Types.parameterize(opClass, types);
		final Nil<?>[] nils = new Nil[inTypes.length + 1];
		System.arraycopy(inTypes, 0, nils, 0, inTypes.length);
		nils[nils.length - 1] = outType;
		return (T) env.op(opName, Nil.of(specialType), nils, outType);
	}

	@SuppressWarnings({ "unchecked" })
	private static <T> T matchHelper(final OpEnvironment env, final String opName, final Hints hints, final Class<T> opClass, final Nil<?> outType, final Nil<?>... inTypes)
	{
		final Type[] types = new Type[inTypes.length + 1];
		for (int i = 0; i < inTypes.length; i++)
			types[i] = inTypes[i].getType();
		types[types.length - 1] = outType.getType();
		final Type specialType = Types.parameterize(opClass, types);
		final Nil<?>[] nils = new Nil[inTypes.length + 1];
		System.arraycopy(inTypes, 0, nils, 0, inTypes.length);
		nils[nils.length - 1] = outType;
		return (T) env.op(opName, Nil.of(specialType), nils, outType, hints);
	}
}
