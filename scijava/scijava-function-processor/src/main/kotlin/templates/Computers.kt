package templates

import main.plusAssign
import java.io.File

class Computers(sourceDir: File) : Globals(sourceDir, "Computers") {

    val arities = 0..maxArity

    fun nilArgs(arity: Int): String {
        val names = nilNames(arity).toMutableList()
        val outType = names.last()
        names[names.lastIndex] = names[0]
        names[0] = outType
        return names.joinToString()
    }

    fun matchParams(arity: Int): String {
        // contains "I1, I2, ..., IN, O"
        val generics = genericParamTypes(arity)
        // contains "in1, in2, ..., inN, out"
        val names = nilNames(arity)
        // constructing strings of the term "final Nil<I1> in1"
        val nilArgs = (0..arity).map { "final Nil<${generics[it]}> ${names[it]}" }
        return nilArgs.joinToString()
    }

    override fun generate(text: StringBuilder) {
        text += """/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.function;

import java.util.HashMap;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

/**
 * Container class for computer-style functional interfaces at various
 * <a href="https://en.wikipedia.org/wiki/Arity">arities</a>.
 * <p>
 * A computer has functional method {@code compute} with a number of arguments
 * corresponding to the arity, plus an additional argument for the preallocated
 * output to be populated by the computation.
 * </p>
 * <p>
 * Each computer interface implements a corresponding {@link Consumer}-style
 * interface (see {@link Consumers}) with arity+1; the consumer's {@code accept}
 * method simply delegates to {@code compute}. This pattern allows computer ops
 * to be used directly as consumers as needed.
 * </p>
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public final class Computers {

	private Computers() {
		// NB: Prevent instantiation of utility class.
	}

	// -- Static Utility Methods -- //

	/**
	 * All known computer types and their arities. The entries are sorted by
	 * arity, i.e., the {@code i}-th entry has an arity of {@code i}.
	 */
	public static final HashMap<Class<?>, Integer> ALL_COMPUTERS;

	static {
		ALL_COMPUTERS = new HashMap<>();"""

        for (arity in arities)
            text += "\t\tALL_COMPUTERS.put(Computers.Arity$arity.class, $arity);"

        text += """	}

	/**
	 * @return {@code true} if the given type is a known
	 *         computer type, {@code false} otherwise. <br>
	 *         Note that only the type itself and not its type hierarchy is
	 *         considered.
	 * @throws NullPointerException If {@code c} is {@code null}.
	 */
	public static boolean isComputer(Class<?> c) {
		return ALL_COMPUTERS.containsKey(c);
	}
"""
        for(arity in arities) {
            val rawClass = "Arity$arity"
            val genericParams = generics(arity)
            val gClass = "$rawClass$genericParams"
            text += """
	@FunctionalInterface
	public interface $gClass extends
		${consumerArity(arity)}$genericParams
	{

		void compute(${computeParams(arity)});

		@Override
		default void accept(${acceptParams(arity)})
		{
			compute(${computeArgs(arity)});
		}
	}"""
        }
        text += "}"
    }
}