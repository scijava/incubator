package templates

import main.plusAssign
import java.io.File

class Inplaces(sourceDir: File) : Globals(sourceDir, "Inplaces") {

    val arities = 1..maxArity

    fun simplifiedClass(arity: Int, num: Int) = "${simplifiedInplace(arity, num)}.class"

    fun inplaceClass(arity: Int, num: Int) = "${inplaceType(arity, num)}.class"

    fun typeVarNums(arity: Int, io: Int): List<Any> {
        val a = (1..arity).toList()
        return a.subList(0, io - 1) + 'O' + a.subList(io, arity)
    }

    fun genericsList(arity: Int, io: Int) = typeVarNums(arity, io).map { "I$it" }

    fun generics(arity: Int, io: Int) = "<${genericsList(arity, io).joinToString()}>"

    fun allMutableGenericsList(arity: Int) = (1..arity).map { "IO$it" }

    fun allMutableGenerics(arity: Int) = "<${allMutableGenericsList(arity).joinToString()}>"

    fun basicParamsList(arity: Int, io: Int) = typeVarNums(arity, io).map { if (it == 'O') "ioType" else "in${it}Type" }

    fun basicParams(arity: Int, io: Int) = basicParamsList(arity, io).joinToString()

    fun matchName(arity: Int, num: Int) = if (arity == 1) "match" else "match$num"

    fun matchParams(arity: Int, io: Int) = genericsList(arity, io).joinToString {
        if (it[1] == 'O')
            "final Nil<$it> ${it.toLowerCase()}Type"
        else
            "final Nil<$it> in${it.drop(1)}Type"
    }

    fun typeArgs(arity: Int, io: Int) = basicParamsList(arity, io).joinToString { "$it.getType()" }

    fun allMutableMutateParams(arity: Int) = allMutableGenericsList(arity).joinToString { "@Mutable $it ${it.toLowerCase()}" }

    fun allMutableMutateArgs(arity: Int) = allMutableGenericsList(arity).joinToString { it.toLowerCase() }

    fun mutateArgs(arity: Int, io: Int) = genericsList(arity, io).joinToString {
        if (it.substring(1) == "O")
            "@Mutable IO io"
        else "$it in${it.drop(1)}"
    }

    override fun generate(text: StringBuilder) {

        text += """/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.function;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * Container class for inplace-style functional interfaces at various
 * <a href="https://en.wikipedia.org/wiki/Arity">arities</a>.
 * <p>
 * An inplace has functional method {@code mutate} with a number of arguments
 * corresponding to the arity. Any of the arguments annotated
 * with @{@link Mutable} may be mutated during execution. Some interfaces narrow
 * this behavior to only a specific argument; most ops in practice will
 * implement one of these narrowed interfaces. For example,
 * {@link Inplaces.Arity2_1} is a binary inplace op that mutates the first of
 * two arguments&mdash;e.g., an {@code a /= b} division operation would be an
 * {@link Inplaces.Arity2_1}, whereas {@code b = a / b} would be an
 * {@link Inplaces.Arity2_2}.
 * </p>
 * <p>
 * Each inplace interface implements a corresponding {@link Consumer}-style
 * interface (see {@link Consumers}) with same arity; the consumer's
 * {@code accept} method simply delegates to {@code mutate}. This pattern allows
 * inplace ops to be used directly as consumers as needed.
 * </p>
 * <p>
 * Note that there is no nullary (arity 0) inplace interface, because there
 * would be no arguments to mutate; see also {@link Consumers.Arity0},
 * {@link Computers.Arity0} and {@link Producer}.
 * </p>
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public final class Inplaces {

	private Inplaces() {
		// NB: Prevent instantiation of container class.
	}

	/**
	 * All known inplace types and their arities and mutable positions. The
	 * entries are sorted by arity and mutable position.
	 */
	public static final Map<Class<?>, InplaceInfo> ALL_INPLACES;

	static {
		final Map<Class<?>, InplaceInfo> inplaces = new LinkedHashMap<>(22);"""

        for (arity in arities)
            for (a in 1..arity) {
                val inplaceIndex = a - 1
                text += "\t\tinplaces.put(${inplaceClass(arity, a)}, new InplaceInfo($arity, $inplaceIndex));"
            }

        text += """		ALL_INPLACES = Collections.unmodifiableMap(inplaces);
	}

	/**
	 * @return {@code true} if the given type is a known
	 *         inplace type, {@code false} otherwise. <br>
	 *         Note that only the type itself and not its type hierarchy is
	 *         considered.
	 * @throws NullPointerException If {@code c} is {@code null}.
	 */
	public static boolean isInplace(Class<?> c) {
		return ALL_INPLACES.containsKey(c);
	}

	public static List<Class<?>> getInplacesOfArity(final int arity) {
		return ALL_INPLACES.entrySet().stream() //
			.filter(e -> e.getValue().arity() == arity) //
			.map(Entry<Class<?>, InplaceInfo>::getKey) //
			.collect(Collectors.toList());
	}

	@FunctionalInterface
	public interface Arity1<IO> extends Consumer<IO> {

		void mutate(@Mutable IO io);

		@Override
		default void accept(IO io) {
			mutate(io);
		}
	}
"""

        for (arity in 2..maxArity) {
            val cArity = arity - 1
            text += """	@FunctionalInterface
	public interface Arity$arity${allMutableGenerics(arity)} extends ${consumerArity(cArity)}${allMutableGenerics(arity)}
	{

		void mutate(${allMutableMutateParams(arity)});

		@Override
		default void accept(${allMutableMutateParams(arity)})
		{
			mutate(${allMutableMutateArgs(arity)});
		}
	}
"""
            for (a in 1..arity)
                text += """	@FunctionalInterface
    public interface ${simplifiedInplace(arity, a)}${generics(arity, a)} extends Arity$arity${generics(arity, a)}
    {

        @Override
        void mutate(${mutateArgs(arity, a)});
    }
"""
        }
                text+="""	public static class InplaceInfo {

        private final int arity;
        private final int mutablePosition;

        public InplaceInfo(final int arity, final int mutablePosition) {
            this.arity = arity;
            this.mutablePosition = mutablePosition;
        }

        public int arity() {
            return arity;
        }

        public int mutablePosition() {
            return mutablePosition;
        }
    }
}
"""
    }
}