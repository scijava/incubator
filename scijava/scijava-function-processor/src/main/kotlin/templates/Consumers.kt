package templates

import main.plusAssign
import java.io.File

class Consumers(sourceDir: File) : Globals(sourceDir, "Consumers") {

    val arities = 3..numConsumers

    fun genericsList(arity: Int) = (1..arity).map { "I$it" }

    override fun genericsNamesList(arity: Int) = genericsList(arity).map { "in${it.drop(1)}" }

    override fun nilNames(arity: Int) = genericsNamesList(arity).map { "${it}Type" }

    override fun typeParamsList(arity: Int): List<String> {
        val generics = genericsList(arity)
        val names = genericsNamesList(arity)
        return (0..arity - 1).map { "${generics[it]} ${names[it]}" }
    }

    fun objectString(arity: Int) = (1..arity).joinToString { "Object" }

    override fun generics(arity: Int) = "<${genericsList(arity).joinToString()}>"

    fun superGenerics(arity: Int) = "<${genericsList(arity).joinToString { "? super $it" }}>"

    fun genericName(arity: Int, num: Int) = genericsNamesList(arity)[num - 1]

    fun generic(arity: Int, num: Int) = genericsList(arity)[num - 1]

    override fun generate(text: StringBuilder) {

        text += """/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.function;

import java.util.Objects;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

/**
 * Container class for
 * higher-<a href="https://en.wikipedia.org/wiki/Arity">arity</a>
 * {@link Consumer}-style functional interfaces&mdash;i.e. with functional
 * method {@code accept} with a number of arguments corresponding to the arity.
 * <ul>
 * <li>For 1-arity (unary) consumers, use {@link Consumer}.</li>
 * <li>For 2-arity (binary) consumers, use {@link BiConsumer}.</li>
 * </ul>
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public final class Consumers {

	private Consumers() {
		// NB: Prevent instantiation of container class.
	}

	/**
	 * Represents an operation that accepts no input arguments and returns no
	 * result. This is the zero-arity specialization of {@link Consumer}. Unlike
	 * most other functional interfaces, this interface is expected to operate via
	 * side-effects.
	 * <p>
	 * This is a functional interface whose functional method is
	 * {@link #[[#]]#accept()}.
	 * </p>
	 *
	 * @see Consumer
	 */
	@FunctionalInterface
	public interface Arity0 extends Runnable {

		/**
		 * Performs the operation.
		 */
		void accept();

		@Override
		default void run() {
			accept();
		}

		/**
		 * Returns a composed {@code Consumer.Arity0} that performs, in sequence,
		 * this operation followed by the {@code after} operation. If performing
		 * either operation throws an exception, it is relayed to the caller of the
		 * composed operation. If performing this operation throws an exception, the
		 * {@code after} operation will not be performed.
		 *
		 * @param after the operation to perform after this operation
		 * @return a composed {@code Consumer.Arity0} that performs in sequence this
		 *         operation followed by the {@code after} operation
		 * @throws NullPointerException if {@code after} is null
		 */
		default Arity0 andThen(Arity0 after) {
			Objects.requireNonNull(after);

			return () -> {
				accept();
				after.accept();
			};
		}
	}
"""
        for (arity in arities) {

            text += """    /**
	 * Represents an operation that accepts $arity input arguments and returns no
	 * result. This is the $arity-arity specialization of {@link Consumer}. Unlike most
	 * other functional interfaces, this interface is expected to operate via
	 * side-effects.
	 * <p>
	 * This is a functional interface whose functional method is
	 * {@link #accept(${objectString(arity)})}.
	 * </p>
	 *"""
            for (a in 1..arity)
                text += "\t* @param <${generic(arity, a)}> the type of argument $a."

            text += """	 * @see Consumer
	 */
	@FunctionalInterface
	public interface Arity$arity${generics(arity)} {

		/**
		 * Performs this operation on the given arguments.
		 *"""
            for (a in 1..arity)
                text += "\t\t* @param ${genericName(arity, a)} input argument $a."

            text += """		 */
		void accept(${acceptParams(arity)});

		/**
		 * Returns a composed {@code Consumer.Arity${arity}} that performs, in sequence,
		 * this operation followed by the {@code after} operation. If performing
		 * either operation throws an exception, it is relayed to the caller of the
		 * composed operation. If performing this operation throws an exception, the
		 * {@code after} operation will not be performed.
		 *
		 * @param after the operation to perform after this operation
		 * @return a composed {@code Consumer.Arity${arity}} that performs in sequence this
		 *         operation followed by the {@code after} operation
		 * @throws NullPointerException if {@code after} is null
		 */
		default Arity$arity${generics(arity)} andThen(Arity$arity${superGenerics(arity)} after)
		{
			Objects.requireNonNull(after);

			return (${acceptArgs(arity)}) -> {
				accept(${acceptArgs(arity)});
				after.accept(${acceptArgs(arity)});
			};
		}
	}
"""
        }
        text += "}"
    }
}