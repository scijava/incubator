package templates

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import templates.Globals
import main.plusAssign

class Consumers_gen(generator: CodeGenerator): Globals() {

    fun genericsList(arity: Int) = (1..arity).map { "I$it" }

    override fun genericsNamesList(arity: Int) = genericsList(arity).map { "in${it.drop(1)}" }

    //    nilNames = ```
    //    { arity ->
    //        genericsNamesList(arity).stream().map{a -> "${a}Type"}.collect()
    //    }
    //    ```
    override fun typeParamsList(arity: Int): List<String> {
        val generics = genericsList(arity)
        val names = genericsNamesList(arity)
        return (0 until arity).map { "${names[it]}: ${generics[it]}" }
    }

    //
    //    [Consumers.java]
    //    objectString =```
    //    { arity ->
    //        String.join(', ', (1..arity).stream().map{a -> "Object"}.collect())
    //    }

    override fun generics(arity: Int) = "<${genericsList(arity).joinToString()}>"

    fun superGenerics(arity: Int) = "<${genericsList(arity).joinToString { "in $it" }}>"

    fun genericName(arity: Int, num: Int) = genericsNamesList(arity)[num - 1]

    fun generic(arity: Int, num: Int) = genericsList(arity)[num - 1]

    init {

        generator.createNewFile(dependencies = Dependencies(false),
                                packageName = "org.scijava.function",
                                fileName = "Consumers").use {

            val text = StringBuilder()

            text += """/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */
package org.scijava.function

import java.lang.FunctionalInterface
import java.lang.Runnable
import java.util.*

/**
 * Container class for
 * higher-[arity](https://en.wikipedia.org/wiki/Arity)
 * [Consumer]-style functional interfaces i.e. with functional
 * method `accept` with a number of arguments corresponding to the arity.
 *
 *  * For 1-arity (unary) consumers, use [Consumer].
 *  * For 2-arity (binary) consumers, use [BiConsumer].
 *
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
object Consumers {
    /**
     * Represents an operation that accepts no input arguments and returns no
     * result. This is the zero-arity specialization of [Consumer]. Unlike
     * most other functional interfaces, this interface is expected to operate via
     * side-effects.
     *
     *
     * This is a functional interface whose functional method is [accept].
     *
     *
     * @see Consumer
     */
    @FunctionalInterface interface Arity0 : Runnable {
        /**
         * Performs the operation.
         */
        fun accept()
        override fun run() = accept()

        /**
         * Returns a composed `Consumer.Arity0` that performs, in sequence,
         * this operation followed by the `after` operation. If performing
         * either operation throws an exception, it is relayed to the caller of the
         * composed operation. If performing this operation throws an exception, the
         * `after` operation will not be performed.
         *
         * @param after the operation to perform after this operation
         * @return a composed `Consumer.Arity0` that performs in sequence this
         * operation followed by the `after` operation
         * @throws NullPointerException if `after` is null
         */
        infix fun andThen(after: Arity0): Arity0 =
            object : Arity0 {
                override fun accept() {
                    accept()
                    after.accept()
                }
            }
    }
"""
            for (arity in 3..numConsumers) {
                text += """
    /**
     * Represents an operation that accepts $arity input arguments and returns no
     * result. This is the $arity-arity specialization of [Consumer]. Unlike most
     * other functional interfaces, this interface is expected to operate via
     * side-effects.
     *
     * This is a functional interface whose functional method is [accept].
     *"""
                for (a in 1..arity)
                    text += "\t* @param ${generic(arity, a)} the type of argument $a."
                text +=
                    """    * @see Consumer
    */
    fun interface Arity${arity}${generics(arity)} {
        /**
         * Performs this operation on the given arguments.
         *"""
                for (a in 1..arity)
                    text += "\t\t* @param ${genericName(arity, a)} input argument $a."
                text +=
                    """        */
		fun accept(${acceptParams(arity)})
    
        /**
         * Returns a composed {@code Consumer.Arity${arity}} that performs, in sequence,
         * this operation followed by the {@code after} operation. If performing
         * either operation throws an exception, it is relayed to the caller of the
         * composed operation. If performing this operation throws an exception, the
         * {@code after} operation will not be performed.
         *
         * @param after the operation to perform after this operation
         * @return a composed {@code Consumer.Arity${arity}} that performs in sequence this
         *         operation followed by the {@code after} operation
         * @throws NullPointerException if {@code after} is null
         */
        infix fun andThen(after: Arity$arity${superGenerics(arity)}): Arity$arity${generics(arity)} =
            Arity$arity { ${acceptParams(arity)} ->
                accept(${acceptArgs(arity)})
				after.accept(${acceptArgs(arity)})
            }
    }"""

            }
            text += "}"

            it.write(text.toString().toByteArray())
        }
    }
}